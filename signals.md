# Signals

## What is a signal?

Signals are software interrupts. They provide a way of handling asynchronous events.
- E.g., a user at a terminal typing the interrupt key to stop a program.

Every signal has a name. The name begins with the three characters SIG.
- E.g., SIGABRT is the abort signal generated when a process calls the abort function
- E.g., SIGALRM is the alarm signal generated when the timer set by the alarm function goes off.

## What is the purpose of signals?

1. A way for humans to interact with programs using the terminal
    - Ctrl+C sends an interrupt signal SIGINT
    - Ctrl+D sends EOF signal
    - Ctrl+Z suspends the process by sending SIGSTP
2. Most importantly, a mechanism for the Kernel for making processes behave according to specifications
    - SIGSEGV is sent on memory exceptions
    - SIGILL is sent on seeing illegal instructions
    - SIGPIPE is sent when on attempts to use a broken pipe

## What can a process do about a signal?

Signals are classic examples of asynchronous events. They occur at random times to the process. The process can't simply test a variable (such as errno) to see whether a signal has occured; instead, thd process as to tell the kernel *"if and when this signal occurs, do the following"*.

A program can tell the kernel to do one of three things when a signal occurs. We call this the *disposition* of the signal, or the *action associated* with a signal.

1. **Accept the default action.** All signals have a default action.
    - `signal (SIGINT, SIG_DFL)`
2. **Ignore the signal.** This works for most signals.
    - `signal (SIGINT, SIG_IGN)`
3. **Catch the signal** (call a function). This tells the Kernel to invoke a given function (signal handler) whenever a signal occurs.
    - `signal (SIGINT, do_something)`

The action in many cases indicates a default action.
- You can override the action for some signals (e.g., SIGINT, SIGUSRx, SIGTERM, SIGSTP).
- For others (SIGKILL, SIGILL, SIGFPE, SIGSEGV, SIGSTOP) you cannot override the action.
- "Overriding" is also called "signal handling" or "catching".
- SIGCHILD is the only signal so far that is ignored by default.
- Most others will kill the process except for SIGCONT and SIGSTP.

Can you kill any process by sending any signal? No, you can only signal processes that you created.

`SIGSTP` (suspends a process) and `SIGCONT` (continues/unsuspends a process) are very useful for *"job control"*
- How to control a process group tied by a shell session?
- All processes that you run make a group of processes that need special controlling.
- You may suspend a process, run it in the background, or move it to the foreground.
- What happens to standard input/output of a background process?

## Where do signals come from?

**User:** Terminal-generated signals – triggered when the user presses a certain key on the terminal (e.g., ^C).
- `kill(2)` function: Sends any signal to another process
- `kill(1)` command: The command-line interface to `kill(2)`
- `raise(3)`: Sends a signal to itself
- Note: a user can send signals to only their owned processes

**Kernel:** Exception-generated signals – CPU execution detects condition and notifies Kernel (e.g., `SIGFPE` divide by 0, `SIGSEGV` invalid memory reference, `SIGILL` when an instruction with illegal opcode is found).

**Processes:** Software-condition generated signals – triggered by software event (e.g., `SIGURG` by out-of-band data on network connection, `SIGPIPE` by broken pipe, `SIGALRM` by timer)

## Generating Signals: `kill(2)` and `raise(3)`

```c++
#include <signal.h>

int kill(pid_t pid, int sig); // send signal 'sig' to process 'pid'
```

```c++
/* example: send signal SIGUSR1 to process 1234 */
if (kill(1234, SIGUSR1) == -1) {
    perror("Failed to send SIGUSR1 signal");
}

/* example: kill parent process */
if (kill(getppid(), SIGTERM) == -1) {
    perror("Failed to kill parent);
}
```

```c++
#include <signal.h>

int raise(int sig); // sends signal 'sig' to itself (part of ANSI C library)
```

- Raise sends a signal to the executing process
- Kill sends a signal to the specified process

## Signals and the Kernel

Many of the signals are generated by the Kernel in response to events and exceptions received:
- **SIGFPE** – FP exception
- **SIGILL** – Illegal instruction
- **SIGSEGV** – Segment violation

All others are routed through the Kernel, if not originating from the Kernel itself
- E.g., SIGHUP (terminal hang), SIGINT (CTRL-C keyboard), SIGSTP (CTRL-Z), SIGKILL (KILL)

## Example: One Handler for One Signal

```c++
/* handler to perform an operation if CTRL-C */
void sighandler(int signum) {
    printf("\nSignal caught!\n");
}

int main() {
    // handle the signal
    // define what to do when a signal is received
    // sighandler is the disposition when CTRL-C is received
    signal(SIGINT, sighandler);

    for (int i = 0; i < 5; i++) {
        printf("Sleeping...\n");
        sleep(5);
        printf("Awake\n");
    }
}
```

```
Sleeping...
Awake
^C
Signal caught!
Sleeping...
Awake
```

## Example: One Handler for Multiple Signals

```c++
void sig_usr(int signo) { // argument is a signal number
    if (signo == SIGUSR1) {
        printf("received SIGUSR1\n");
    } else if (signo == SIGUSR2) {
        printf("received SIGUSR2\n");
    } else {
        error_dump("received signal %d\n", signo);
    }
    return;
}

int main(void) {
    if (signal(SIGUSR1, sig_usr) == SIG_ERR) {
        perror("cannot catch signal SIGUSR1");
    }
    if (signal(SIGUSR2, sig_usr) == SIG_ERR) {
        perror("cannot catch signal SIGUSR2");
    }
    for (;;) {
        pause();
    }
}
```

## Reaping Child Processes

When a child process terminates, it generates SIGCHLD for the parent process.

The parent can handle this signal by reaping the child process.

This is asynchronous, i.e., the parent process can do other things instead of continuously waiting.

```c++
void my_handler(int sig) {
    wait(0);
}

int main() {
    // install handler
    signal(SIGCHLD, my_handler);

    // create 5 child procs
    // ith proc sleeps i sec and then dies
    for (int i = 1; i <= 5; i++) {
        int pid = fork();
        if (pid == 0) {
            sleep(i);
            return 0;
        }
    }
    // parent in an infinite loop
    // busy doing something else
    while (true) {
        cout << "Relaxing" << endl;
        sleep(1);
    }
}
```

## Reaping Child Processes with Simultaneous Termination

```c++
void my_handler(int sig) {
   while (waitpid(-1, 0, 0) != -1) {
    ;
   }
}

int main() {
    // install handler
    signal(SIGCHLD, my_handler);

    // create 5 child procs
    // ith proc sleeps i sec and then dies
    for (int i = 1; i <= 5; i++) {
        int pid = fork();
        if (pid == 0) {
            sleep(5); // all die simultaneously
            return 0;
        }
    }
    // parent in an infinite loop
    // busy doing something else
    while (true) {
        cout << "Relaxing" << endl;
        sleep(1);
    }
}
```

## `signal` Function

The simplest interface to the signal features of the UNIX system is the `signal` function

```c++
#include <signal.h>

void (*signal(int signo, void (*func) (int))) (int);
// returns: previous disposition of signal if OK, SIG_ERR on error
```

`signo` is the name of the signal

`func` is the constant SIG_IGN, the constant SIG_DFL, or the address of a function call when the signal occurs
- SIG_IGN tells the system to ignore the signal
- SIG_DFL sets the action associated with the signal to its default value
- When we specify the address of a function to be called when the signal occurs, we are *catching* the signal. This function is called the *signal handler*.

## `kill` and `raise` Functions

The term kill in the UNIX system is a *misnomer*.

The `kill()` function *sends a signal* to a process or a group of processes.

The `raise()` function allows a process to send a signal to itself.

```c++
#include <signal.h>

int kill(pid_t pid, int signo);

int raise(int signo);
```

The call `raise(signo)` is equivalent to the call `kill(getpid(), signo)`.

## `kill` Function

There are four different conditions for the pid argument to kill
- **pid > 0:** The signal is sent to the process whose process ID is pid
- **pid == 0:** The signal is sent to all processes whose process group ID equals the process group ID of the sender and for which the sender has permission to send the signal
- **pid < 0:** The signal is sent to all processes whose process group ID equals the absolute value of pid and for which the sender has permission to send the signal
- **pid == -1:** The signal is sent to all processes on the system for which the sender has permission to send the signal

## `alarm` Function

The alarm function sets a timer that will expire at a specified time in the future. When the timer expires, the SIGALRM signal is generated.

If we ignore or don't catch this signal, its default action is to terminate the process.

```c++
#include <unistd.h>

unsigned int alarm(unsigned int seconds);
// returns: 0 or number of seconds until previously set alarm
```

- The seconds value is the number of clock seconds in the future when the signal should be generated.
- When that time occurs, the signal is generated by the kernel, although additional time could elapse before the process gets control to handle the signal, because of processor scheduling delays.
- There is only one of these alarm clocks per process. If, when we call alarm, a previously registered alarm clock for the process has not yet expired, the number of seconds left for that alarm clock is returned as the value of this function. That previously registered alarm clock is replaced by the new value.
- If a previously registered alarm clock for the process has not yet expired and if the seconds value is 0, the previous alarm clock is canceled. The number of seconds left for that previous alarm clock is still returned as the value of the function.

## `pause` Function

The pause function suspends the calling process until a signal is caught.

```c++
#include <unistd.h>

int pause(void);
// returns: -1 with errno set to EINTR
```

The only time pause returns is if a signal handler is executed and that handler returns. In that case, pause returns -1 with errno set to EINTR.

## Signal Sets

POSIX.1 defines the data type `sigset_t` to contain a signal set and the following five functions to manipulate signal sets (multiple signals).

```c++
#include <signal.h>

int sigemptyset(sigset_t *set);
int sigfillset(sigset_t *set);
int sigaddset(sigset_t *set, int signo);
int sigdelset(sigset_t *set, int signo);
int sigismember(const sigset_t *set, int signo);
// returns: 1 if true, 0 if false, -1 on error
```

- `sigemptyset` initializes the signal set point to by `set` so that all signals are excluded.
- `sigfillset` initializes the signal set so that all signals are included. All applications have to call either `sigemptyset` or `sigfillset` once for each signal set, before using the signal set.
- `sigaddset` adds a single signal to an existing set.
- `sigdelset` removes a single signal from a set.

In all the functions that take a signal set as an argument, we always pass the address of the signal set as the argument.

## Automatic and Manual Signal Blocking

Blocking is *automatic* for a signal type when the same signal is being handled.
1. First, if SIGINT is received, the process calls the SIGINT handler.
2. Next, SIGINT is blocked for the process, i.e., if another SIGINT occurs during the handler execution, it is recorded in the pending bit vector, but not delivered.
3. When the handler returns, signals of that type can start to be delivered again.

However, a process can *manually* block the delivery of a signal.

The signal remains blocked until the process either unblocks it, or changes the action to ignore the signal.

`sigprocmask()` manipulates the set of blocked signals for the process.

## `sigprocmask` Function

The *signal mask* of a process is the set of signals currently blocked from delivery to that process.

A process can *examine* its signal mask, *change* its signal mask, or perform both operations in one step by calling the following function:

```c
int sigprocmask(int option, const sigset_t *__restrict__ new_set, sigset_t *__restrict__ old_set);
```

- `option`: Indicates the way in which the existing set of blocked signals should be changed (SIG_BLOCK, SIG_UNBLOCK, SIG_SETMASK)
- `new_set`: Points to a signal set giving the new signals that should be blocked or unblocked
- `old_set`: Points to a memory location where `sigprocmask()` can store a signal set

- **SIG_BLOCK:** The new signal mask for the process is the union of its current signal mask and the signal set pointed to by `set`. That is, `set` contains the additional signals that we want to block.
- **SIG_UNBLOCK:** The new signal mask for the process is the intersection of its current signal mask and the complement of the signal set pointed to by `set`. That is, `set` contains the signals that we want to unblock.
- **SIG_SETMASK:** The new signal mask for the process is replaced by the value of the signal set pointed to by `set`.

## `sigaction` Function

The `sigaction()` function examines, changes, or both examines and changes the action associated with a specific signal.

```c
#include <signal.h>

int sigaction(int signo, const struct sigaction *restrict act, struct sigaction *restrict oact);
```

- `sig`: (Input) A signal from the list defined in the Control Signals Table.
- `*act`: (Input) A pointer to the `sigaction` structure that describes the action to be taken for the signal.
    - If `act` is `NULL`, signal handling is unchanged.
    - If `act` is not `NULL`, the action specified in the `sigaction` structure becomes the new action associated with `sig`
- `*oact`: (Output) A pointer to a storage location where `sigaction()` can store a `sigaction` structure. This structure contains the action currently associated with `sig`.
    - If `oact` is `NULL`, `sigaction()` does not store this information.

```c
struct sigaction {
    void     (*sa_handler) (int);   // addr of signal handler
    sigset_t sa_mask;               // additional signals to block
    int      sa_flags;              // signal options
    void     (*sa_sigaction) (int, siginfo_t *, void *);
}
```

- `sa_handler`: A pointer to the function assigned to handle the signal.
- `sa_mask`: A signal set to be added to the signal mask of the calling process before the signal-catching function `sa_handler` is called.
- `sa_flags`: A collection of flag bits that affect the behavior or signals.
- `sa_sigaction`: A pointer to the function assigned to handle the signal.